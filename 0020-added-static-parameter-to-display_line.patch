From 6a06a3ee93dfd8d497cd0ea5ceab860693b63106 Mon Sep 17 00:00:00 2001
From: Kim Eik <kim@heldig.org>
Date: Wed, 9 May 2012 15:22:34 +0200
Subject: [PATCH 20/32] added static parameter to display_line

the static parameter (default false), when set to true will disable all controls on a map,
effectively making the map read-only.

Change-Id: Iaecface3ac1ee70e84d99b954fc94482b330bb86
---
 includes/parserHooks/Maps_DisplayLine.php         |    9 +-
 includes/services/GoogleMaps3/jquery.googlemap.js | 1007 +++++++++++----------
 includes/services/OpenLayers/jquery.openlayers.js |  888 +++++++++---------
 3 files changed, 970 insertions(+), 934 deletions(-)

diff --git a/includes/parserHooks/Maps_DisplayLine.php b/includes/parserHooks/Maps_DisplayLine.php
index 6ff71d2..881411b 100644
--- a/includes/parserHooks/Maps_DisplayLine.php
+++ b/includes/parserHooks/Maps_DisplayLine.php
@@ -104,6 +104,13 @@ class MapsDisplayLine extends MapsDisplayPoint {
 		$params['searchmarkers']->addCriteria( new CriterionSearchMarkers() );
 		$params['searchmarkers']->setDoManipulationOfDefault( false );
 
+		$params['static'] = new Parameter(
+			'static' ,
+			Parameter::TYPE_BOOLEAN
+		);
+		$params['static']->setDefault( false );
+		$params['static']->setDoManipulationOfDefault( false );
+
 		return $params;
 	}
 
@@ -116,6 +123,6 @@ class MapsDisplayLine extends MapsDisplayPoint {
 	 * @return array
 	 */
 	protected function getDefaultParameters( $type ) {
-		return array( 'coordinates' , 'lines' , 'polygons' );
+		return array( 'coordinates' , 'lines' , 'polygons' , 'circles' , 'rectangles' );
 	}
 }
\ No newline at end of file
diff --git a/includes/services/GoogleMaps3/jquery.googlemap.js b/includes/services/GoogleMaps3/jquery.googlemap.js
index 292f052..0ac5c7e 100644
--- a/includes/services/GoogleMaps3/jquery.googlemap.js
+++ b/includes/services/GoogleMaps3/jquery.googlemap.js
@@ -5,596 +5,619 @@
  * @author Jeroen De Dauw <jeroendedauw at gmail dot com>
  */
 
-(function( $, mw ){ $.fn.googlemaps = function( options ) {
-
-	var _this = this;
-	this.map = null;
-	this.markercluster = null;
-	this.options = options;
-
-	/**
-	 * All markers that are currently on the map.
-	 * @type {Array}
-	 * @private
-	 */
-	this.markers = [];
-
-	/**
-	 * All Polylines currently on the map,
-	 * @type {Array}
-	 * @private
-	 */
-	this.lines = [];
-
-	/**
-	 * All polygons currently on the map,
-	 */
-	this.polygons = [];
-
-
-	/**
-	 * All circles on the map
-	 */
-	this.circles = [];
-
-
-	/**
-	 * All rectangles on the map
-	 */
-	this.rectangles = [];
-
-	/**
-	 * Creates a new marker with the provided data,
-	 * adds it to the map, and returns it.
-	 * @param {Object} markerData Contains the fields lat, lon, title, text and icon
-	 * @return {google.maps.Marker}
-	 */
-	this.addMarker = function (markerData) {
-		var markerOptions = {
-			position:new google.maps.LatLng(markerData.lat, markerData.lon),
-			title:markerData.title,
-			labelContent:markerData.inlineLabel,
-			labelAnchor:new google.maps.Point(-15, 34),
-			labelClass:'markerwithlabel'
-		};
+(function ($, mw) {
+	$.fn.googlemaps = function (options) {
 
-		if (markerData.icon !== '') {
-			markerOptions.icon = markerData.icon;
-		}
+		var _this = this;
+		this.map = null;
+		this.markercluster = null;
+		this.options = options;
 
-		var marker;
-		if (markerData.inlineLabel === undefined || markerData.inlineLabel.length == 0) {
-			marker = new google.maps.Marker(markerOptions);
-		} else {
-			marker = new MarkerWithLabel(markerOptions);
-		}
+		/**
+		 * All markers that are currently on the map.
+		 * @type {Array}
+		 * @private
+		 */
+		this.markers = [];
 
-		//Add onclick listener
-		google.maps.event.addListener( marker, 'click', function(e) {
-			if (e.target !== undefined && (e.target instanceof HTMLAnchorElement || e.target.tagName == 'A')) {
-				//click link defined in inlinelabel
-				window.location.href = e.target.href;
-			}else{
-				openBubbleOrLink.call(this, markerData, e, marker);
-			}
-		} );
+		/**
+		 * All Polylines currently on the map,
+		 * @type {Array}
+		 * @private
+		 */
+		this.lines = [];
 
-		marker.setMap(this.map);
-		this.markers.push(marker);
+		/**
+		 * All polygons currently on the map,
+		 */
+		this.polygons = [];
 
-		return marker;
-	};
 
-	/**
-	 * Removes a single marker from the map.
-	 * @param {google.maps.Marker} marker The marker to remove.
-	 */
-	this.removeMarker = function( marker ) {
-		marker.setMap( null );
+		/**
+		 * All circles on the map
+		 */
+		this.circles = [];
 
-		for ( var i = this.markers.length - 1; i >= 0; i-- ) {
-			if ( this.markers[i] === marker ) {
-				delete this.markers[i];
-				break;
-			}
-		}
 
-		delete marker;
-	};
+		/**
+		 * All rectangles on the map
+		 */
+		this.rectangles = [];
 
-	/**
-	 * Removes all markers from the map.
-	 */
-	this.removeMarkers = function() {
-		for ( var i = this.markers.length - 1; i >= 0; i-- ) {
-			this.markers[i].setMap( null );
-		}
-		this.markers = [];
-	};
+		/**
+		 * Creates a new marker with the provided data,
+		 * adds it to the map, and returns it.
+		 * @param {Object} markerData Contains the fields lat, lon, title, text and icon
+		 * @return {google.maps.Marker}
+		 */
+		this.addMarker = function (markerData) {
+			var markerOptions = {
+				position:new google.maps.LatLng(markerData.lat, markerData.lon),
+				title:markerData.title,
+				labelContent:markerData.inlineLabel,
+				labelAnchor:new google.maps.Point(-15, 34),
+				labelClass:'markerwithlabel'
+			};
+
+			if (markerData.icon !== '') {
+				markerOptions.icon = markerData.icon;
+			}
 
-	/**
-	 * Remove the "earth" type from options.types if it's present.
-	 *
-	 * @since 1.0.1
-	 */
-	this.removeEarthType = function() {
-		if ( Array.prototype.filter ) {
-			options.types = options.types.filter( function( element, index, array ) { return element !== 'earth'; } );
-		}
-		else {
-			// Seems someone is using the o-so-awesome browser that is IE.
-			var types = [];
+			var marker;
+			if (markerData.inlineLabel === undefined || markerData.inlineLabel.length == 0) {
+				marker = new google.maps.Marker(markerOptions);
+			} else {
+				marker = new MarkerWithLabel(markerOptions);
+			}
 
-			for ( i in options.types ) {
-				if ( typeof( options.types[i] ) !== 'function' && options.types[i] !== 'earth' ) {
-					types.push( options.types[i] );
+			//Add onclick listener
+			google.maps.event.addListener(marker, 'click', function (e) {
+				if (e.target !== undefined && (e.target instanceof HTMLAnchorElement || e.target.tagName == 'A')) {
+					//click link defined in inlinelabel
+					window.location.href = e.target.href;
+				} else {
+					openBubbleOrLink.call(this, markerData, e, marker);
 				}
-			}
+			});
 
-			options.types = types;
-		}
-	};
+			marker.setMap(this.map);
+			this.markers.push(marker);
 
-	this.addOverlays = function() {
-		// Add the Google KML/KMZ layers.
-		for ( i = options.gkml.length - 1; i >= 0; i-- ) {
-			var kmlLayer = new google.maps.KmlLayer(
-				options.gkml[i],
-				{
-					map: this.map,
-					preserveViewport: !options.kmlrezoom
-				}
-			);
-		}
+			return marker;
+		};
 
-		// If there are any non-Google KML/KMZ layers, load the geoxml library and use it to add these layers.
-		if ( options.kml.length != 0 ) {
-			mw.loader.using( 'ext.maps.gm3.geoxml', function() {
-				var geoXml = new geoXML3.parser( { map: _this.map, zoom: options.kmlrezoom } );
-				geoXml.parse( options.kml );
-			} );
-		}
-	};
+		/**
+		 * Removes a single marker from the map.
+		 * @param {google.maps.Marker} marker The marker to remove.
+		 */
+		this.removeMarker = function (marker) {
+			marker.setMap(null);
 
-	this.addLine = function(properties){
-		var paths = new google.maps.MVCArray();
-		for(var x = 0; x < properties.pos.length; x++){
-			paths.push(new google.maps.LatLng( properties.pos[x].lat , properties.pos[x].lon ));
-		}
+			for (var i = this.markers.length - 1; i >= 0; i--) {
+				if (this.markers[i] === marker) {
+					delete this.markers[i];
+					break;
+				}
+			}
 
-		var line = new google.maps.Polyline({
-			map:this.map,
-			path:paths,
-			strokeColor:properties.strokeColor,
-			strokeOpacity:properties.strokeOpacity,
-			strokeWeight:properties.strokeWeight
-		});
-		this.lines.push(line);
-
-		google.maps.event.addListener(line,"click", function(event){
-			openBubbleOrLink.call(this, properties, event, line);
-		});
-	};
+			delete marker;
+		};
 
-	this.removeLine = function(line){
-		line.setMap( null );
+		/**
+		 * Removes all markers from the map.
+		 */
+		this.removeMarkers = function () {
+			for (var i = this.markers.length - 1; i >= 0; i--) {
+				this.markers[i].setMap(null);
+			}
+			this.markers = [];
+		};
 
-		for ( var i = this.line.length - 1; i >= 0; i-- ) {
-			if ( this.line[i] === line ) {
-				delete this.line[i];
-				break;
+		/**
+		 * Remove the "earth" type from options.types if it's present.
+		 *
+		 * @since 1.0.1
+		 */
+		this.removeEarthType = function () {
+			if (Array.prototype.filter) {
+				options.types = options.types.filter(function (element, index, array) {
+					return element !== 'earth';
+				});
 			}
-		}
+			else {
+				// Seems someone is using the o-so-awesome browser that is IE.
+				var types = [];
 
-		delete line;
-	};
+				for (i in options.types) {
+					if (typeof( options.types[i] ) !== 'function' && options.types[i] !== 'earth') {
+						types.push(options.types[i]);
+					}
+				}
 
-	this.removeLines = function(){
-		for ( var i = this.lines.length - 1; i >= 0; i-- ) {
-			this.lines[i].setMap( null );
-		}
-		this.lines = [];
-	};
+				options.types = types;
+			}
+		};
 
-	this.addPolygon = function(properties){
-		var paths = new google.maps.MVCArray();
-		for(var x = 0; x < properties.pos.length; x++){
-			paths.push(new google.maps.LatLng( properties.pos[x].lat , properties.pos[x].lon ));
-		}
+		this.addOverlays = function () {
+			// Add the Google KML/KMZ layers.
+			for (i = options.gkml.length - 1; i >= 0; i--) {
+				var kmlLayer = new google.maps.KmlLayer(
+					options.gkml[i],
+					{
+						map:this.map,
+						preserveViewport:!options.kmlrezoom
+					}
+				);
+			}
 
-		var polygon = new google.maps.Polygon({
-			map:this.map,
-			path:paths,
-			strokeColor:properties.strokeColor,
-			strokeOpacity:properties.strokeOpacity,
-			strokeWeight:properties.strokeWeight,
-			fillColor:properties.fillColor,
-			fillOpacity:properties.fillOpacity
-		});
-		this.polygons.push(polygon);
-
-		//add hover event/effect
-		if(properties.onlyVisibleOnHover === true){
-
-			function hidePolygon(polygon) {
-				polygon.setOptions({
-					fillOpacity:0,
-					strokeOpacity:0
+			// If there are any non-Google KML/KMZ layers, load the geoxml library and use it to add these layers.
+			if (options.kml.length != 0) {
+				mw.loader.using('ext.maps.gm3.geoxml', function () {
+					var geoXml = new geoXML3.parser({ map:_this.map, zoom:options.kmlrezoom });
+					geoXml.parse(options.kml);
 				});
 			}
+		};
 
-			hidePolygon(polygon);
+		this.addLine = function (properties) {
+			var paths = new google.maps.MVCArray();
+			for (var x = 0; x < properties.pos.length; x++) {
+				paths.push(new google.maps.LatLng(properties.pos[x].lat, properties.pos[x].lon));
+			}
 
-			google.maps.event.addListener(polygon,"mouseover",function(){
-				this.setOptions({
-					fillOpacity: properties.fillOpacity,
-					strokeOpacity:properties.strokeOpacity
-				});
+			var line = new google.maps.Polyline({
+				map:this.map,
+				path:paths,
+				strokeColor:properties.strokeColor,
+				strokeOpacity:properties.strokeOpacity,
+				strokeWeight:properties.strokeWeight
 			});
+			this.lines.push(line);
 
-			google.maps.event.addListener(polygon,"mouseout",function(){
-				hidePolygon(this);
+			google.maps.event.addListener(line, "click", function (event) {
+				openBubbleOrLink.call(this, properties, event, line);
 			});
+		};
 
-		}
+		this.removeLine = function (line) {
+			line.setMap(null);
 
-		//add click event
-		google.maps.event.addListener(polygon,"click", function(event){
-			openBubbleOrLink.call(this, properties, event, polygon);
-		});
-	};
+			for (var i = this.line.length - 1; i >= 0; i--) {
+				if (this.line[i] === line) {
+					delete this.line[i];
+					break;
+				}
+			}
 
-	this.addCircle = function(properties){
-		var circle = new google.maps.Circle({
-			map:this.map,
-			center:new google.maps.LatLng(properties.centre.lat,properties.centre.lon),
-			radius: properties.radius,
-			fillColor: properties.fillColor,
-			fillOpacity: properties.fillOpacity,
-			strokeColor: properties.strokeColor,
-			strokeOpacity: properties.strokeOpacity,
-			strokeWeight: properties.strokeWeight
-		});
-		this.circles.push(circle);
-
-		//add click event
-		google.maps.event.addListener(circle,"click", function(event){
-			openBubbleOrLink.call(this, properties, event, circle);
-		});
-	};
+			delete line;
+		};
 
+		this.removeLines = function () {
+			for (var i = this.lines.length - 1; i >= 0; i--) {
+				this.lines[i].setMap(null);
+			}
+			this.lines = [];
+		};
 
-	this.addRectangle = function(properties){
-		var rectangle = new google.maps.Rectangle({
-			map: this.map,
-			bounds: new google.maps.LatLngBounds(
-				new google.maps.LatLng(properties.sw.lat,properties.sw.lon), //sw
-				new google.maps.LatLng(properties.ne.lat,properties.ne.lon)  //ne
-			),
-			fillColor: properties.fillColor,
-			fillOpacity: properties.fillOpacity,
-			strokeColor: properties.strokeColor,
-			strokeOpacity: properties.strokeOpacity,
-			strokeWeight: properties.strokeWeight
-		})
-		this.rectangles.push(rectangle);
-
-		//add click event
-		google.maps.event.addListener(rectangle,"click", function(event){
-			openBubbleOrLink.call(this, properties, event, rectangle);
-		});
-	}
-
-	this.removePolygon = function(polygon){
-		polygon.setMap( null );
-
-		for ( var i = this.polygon.length - 1; i >= 0; i-- ) {
-			if ( this.polygon[i] === polygon ) {
-				delete this.polygon[i];
-				break;
+		this.addPolygon = function (properties) {
+			var paths = new google.maps.MVCArray();
+			for (var x = 0; x < properties.pos.length; x++) {
+				paths.push(new google.maps.LatLng(properties.pos[x].lat, properties.pos[x].lon));
 			}
-		}
 
-		delete polygon;
-	};
+			var polygon = new google.maps.Polygon({
+				map:this.map,
+				path:paths,
+				strokeColor:properties.strokeColor,
+				strokeOpacity:properties.strokeOpacity,
+				strokeWeight:properties.strokeWeight,
+				fillColor:properties.fillColor,
+				fillOpacity:properties.fillOpacity
+			});
+			this.polygons.push(polygon);
 
-	this.removePolygons = function(){
-		for ( var i = this.polygon.length - 1; i >= 0; i-- ) {
-			this.polygon[i].setMap( null );
-		}
-		this.polygon = [];
-	};
+			//add hover event/effect
+			if (properties.onlyVisibleOnHover === true) {
 
-	this.setup = function() {
-		var showEarth = $.inArray( 'earth', options.types ) !== -1;
+				function hidePolygon(polygon) {
+					polygon.setOptions({
+						fillOpacity:0,
+						strokeOpacity:0
+					});
+				}
 
-		// If there are any non-Google KML/KMZ layers, load the geoxml library and use it to add these layers.
-		if ( showEarth ) {
-			this.removeEarthType();
-			showEarth = mw.config.get( 'egGoogleJsApiKey' ) !== '';
-		}
+				hidePolygon(polygon);
 
-		var mapOptions = {
-			disableDefaultUI: true,
-			mapTypeId: options.type == 'earth' ? google.maps.MapTypeId.SATELLITE : eval( 'google.maps.MapTypeId.' + options.type )
-		};
+				google.maps.event.addListener(polygon, "mouseover", function () {
+					this.setOptions({
+						fillOpacity:properties.fillOpacity,
+						strokeOpacity:properties.strokeOpacity
+					});
+				});
 
-		// Map controls
-		mapOptions.panControl = $.inArray( 'pan', options.controls ) != -1;
-		mapOptions.zoomControl = $.inArray( 'zoom', options.controls ) != -1;
-		mapOptions.mapTypeControl = $.inArray( 'type', options.controls ) != -1;
-		mapOptions.scaleControl = $.inArray( 'scale', options.controls ) != -1;
-		mapOptions.streetViewControl = $.inArray( 'streetview', options.controls ) != -1;
+				google.maps.event.addListener(polygon, "mouseout", function () {
+					hidePolygon(this);
+				});
 
-		for ( i in options.types ) {
-			if ( typeof( options.types[i] ) !== 'function' ) {
-				options.types[i] = eval( 'google.maps.MapTypeId.' + options.types[i] );
 			}
-		}
 
-		// Map control styles
-		mapOptions.zoomControlOptions = { style: eval( 'google.maps.ZoomControlStyle.' + options.zoomstyle ) };
-		mapOptions.mapTypeControlOptions = {
-			style: eval( 'google.maps.MapTypeControlStyle.' + options.typestyle ),
-			mapTypeIds: options.types
+			//add click event
+			google.maps.event.addListener(polygon, "click", function (event) {
+				openBubbleOrLink.call(this, properties, event, polygon);
+			});
 		};
 
-		var map = new google.maps.Map( this.get( 0 ), mapOptions );
-		this.map = map;
+		this.addCircle = function (properties) {
+			var circle = new google.maps.Circle({
+				map:this.map,
+				center:new google.maps.LatLng(properties.centre.lat, properties.centre.lon),
+				radius:properties.radius,
+				fillColor:properties.fillColor,
+				fillOpacity:properties.fillOpacity,
+				strokeColor:properties.strokeColor,
+				strokeOpacity:properties.strokeOpacity,
+				strokeWeight:properties.strokeWeight
+			});
+			this.circles.push(circle);
 
-		if ( options.poi === false ) {
-			map.setOptions( { styles: [
-				{
-					featureType: "poi",
-					stylers: [
-						{ visibility: "off" }
-					]
-				}
-			] } );
-		}
+			//add click event
+			google.maps.event.addListener(circle, "click", function (event) {
+				openBubbleOrLink.call(this, properties, event, circle);
+			});
+		};
 
-		if ( !options.locations ) {
-			options.locations = [];
-		}
 
-		// Add the markers.
-		for ( var i = options.locations.length - 1; i >= 0; i-- ) {
-			this.addMarker( options.locations[i] );
+		this.addRectangle = function (properties) {
+			var rectangle = new google.maps.Rectangle({
+				map:this.map,
+				bounds:new google.maps.LatLngBounds(
+					new google.maps.LatLng(properties.sw.lat, properties.sw.lon), //sw
+					new google.maps.LatLng(properties.ne.lat, properties.ne.lon)  //ne
+				),
+				fillColor:properties.fillColor,
+				fillOpacity:properties.fillOpacity,
+				strokeColor:properties.strokeColor,
+				strokeOpacity:properties.strokeOpacity,
+				strokeWeight:properties.strokeWeight
+			})
+			this.rectangles.push(rectangle);
+
+			//add click event
+			google.maps.event.addListener(rectangle, "click", function (event) {
+				openBubbleOrLink.call(this, properties, event, rectangle);
+			});
 		}
 
-		for ( i = options.fusiontables.length - 1; i >= 0; i-- ) {
-			var ftLayer = new google.maps.FusionTablesLayer( options.fusiontables[i], { map: map } );
-		}
+		this.removePolygon = function (polygon) {
+			polygon.setMap(null);
 
-		var layerMapping = {
-			'traffic': 'new google.maps.TrafficLayer()',
-			'bicycling': 'new google.maps.BicyclingLayer()'
+			for (var i = this.polygon.length - 1; i >= 0; i--) {
+				if (this.polygon[i] === polygon) {
+					delete this.polygon[i];
+					break;
+				}
+			}
+
+			delete polygon;
 		};
 
-		for ( i = options.layers.length - 1; i >= 0; i-- ) {
-			var layer = eval( layerMapping[options.layers[i]] );
-			layer.setMap( map );
-		}
+		this.removePolygons = function () {
+			for (var i = this.polygon.length - 1; i >= 0; i--) {
+				this.polygon[i].setMap(null);
+			}
+			this.polygon = [];
+		};
 
-		var bounds;
+		this.setup = function () {
+			var showEarth = $.inArray('earth', options.types) !== -1;
 
-		if ( ( options.centre === false || options.zoom === false ) && options.locations.length > 1 ) {
-			bounds = new google.maps.LatLngBounds();
+			// If there are any non-Google KML/KMZ layers, load the geoxml library and use it to add these layers.
+			if (showEarth) {
+				this.removeEarthType();
+				showEarth = mw.config.get('egGoogleJsApiKey') !== '';
+			}
 
-			for ( var i = this.markers.length - 1; i >= 0; i-- ) {
-				bounds.extend( this.markers[i].getPosition() );
+			var mapOptions = {
+				disableDefaultUI:true,
+				mapTypeId:options.type == 'earth' ? google.maps.MapTypeId.SATELLITE : eval('google.maps.MapTypeId.' + options.type)
+			};
+
+			// Map controls
+			mapOptions.panControl = $.inArray('pan', options.controls) != -1;
+			mapOptions.zoomControl = $.inArray('zoom', options.controls) != -1;
+			mapOptions.mapTypeControl = $.inArray('type', options.controls) != -1;
+			mapOptions.scaleControl = $.inArray('scale', options.controls) != -1;
+			mapOptions.streetViewControl = $.inArray('streetview', options.controls) != -1;
+
+			for (i in options.types) {
+				if (typeof( options.types[i] ) !== 'function') {
+					options.types[i] = eval('google.maps.MapTypeId.' + options.types[i]);
+				}
 			}
-		}
 
-		if ( options.zoom === false ) {
-			map.fitBounds( bounds );
-		}
-		else {
-			map.setZoom( options.zoom );
-		}
+			// Map control styles
+			mapOptions.zoomControlOptions = { style:eval('google.maps.ZoomControlStyle.' + options.zoomstyle) };
+			mapOptions.mapTypeControlOptions = {
+				style:eval('google.maps.MapTypeControlStyle.' + options.typestyle),
+				mapTypeIds:options.types
+			};
+
+			//static mode
+			if (options['static']) {
+				mapOptions.draggable = false;
+				mapOptions.disableDoubleClickZoom = true;
+				mapOptions.panControl = false;
+				mapOptions.rotateControl = false;
+				mapOptions.zoomControl = false;
+				mapOptions.scrollwheel = false;
+				mapOptions.streetViewControl = false;
+				mapOptions.overviewMapControl = false;
+				mapOptions.mapTypeControl = false;
+			}
 
-		var centre;
+			var map = new google.maps.Map(this.get(0), mapOptions);
+			this.map = map;
 
-		if ( options.centre === false ) {
-			if ( options.locations.length > 1 ) {
-				centre = bounds.getCenter();
+			if (options.poi === false) {
+				map.setOptions({ styles:[
+					{
+						featureType:"poi",
+						stylers:[
+							{ visibility:"off" }
+						]
+					}
+				] });
 			}
-			else if ( options.locations.length == 1 ) {
-				centre = new google.maps.LatLng( options.locations[0].lat, options.locations[0].lon );
+
+			if (!options.locations) {
+				options.locations = [];
 			}
-			else {
-				centre = new google.maps.LatLng( 0, 0 );
+
+			// Add the markers.
+			for (var i = options.locations.length - 1; i >= 0; i--) {
+				this.addMarker(options.locations[i]);
 			}
-		}
-		else {
-			centre = new google.maps.LatLng( options.centre.lat, options.centre.lon );
-		}
 
-		map.setCenter( centre );
-
-		if ( showEarth ) {
-			$.getScript(
-				'https://www.google.com/jsapi?key=' + mw.config.get( 'egGoogleJsApiKey' ),
-				function( data, textStatus ) {
-					google.load( 'earth', '1', { callback: function() {
-						mw.loader.using( 'ext.maps.gm3.earth', function() {
-							if ( google.earth.isSupported() ) {
-								var ge = new GoogleEarth( map );
-								var setTilt = function() {
-
-									if ( ge.getInstance() !== undefined ) {
-
-										var center = map.getCenter();
-										var lookAt = ge.instance_.createLookAt('');
-										var range = Math.pow(2, GoogleEarth.MAX_EARTH_ZOOM_ - map.getZoom());
-										lookAt.setRange(range);
-										lookAt.setLatitude(center.lat());
-										lookAt.setLongitude(center.lng());
-										lookAt.setHeading(0);
-										lookAt.setAltitude(0);
-
-										// Teleport to the pre-tilt view immediately.
-										ge.instance_.getOptions().setFlyToSpeed(5);
-										ge.instance_.getView().setAbstractView(lookAt);
-										lookAt.setTilt(options.tilt);
-										// Fly to the tilt at regular speed in 200ms
-										ge.instance_.getOptions().setFlyToSpeed(0.75);
-										window.setTimeout(function() {
-											ge.instance_.getView().setAbstractView(lookAt);
-										}, 200);
-										// Set the flyto speed back to default after the animation starts.
-										window.setTimeout(function() {
-											ge.instance_.getOptions().setFlyToSpeed(1);
-										}, 250);
+			for (i = options.fusiontables.length - 1; i >= 0; i--) {
+				var ftLayer = new google.maps.FusionTablesLayer(options.fusiontables[i], { map:map });
+			}
 
-									}
-									else {
-										setTimeout( function() { setTilt(); }, 100 );
-									}
-								};
+			var layerMapping = {
+				'traffic':'new google.maps.TrafficLayer()',
+				'bicycling':'new google.maps.BicyclingLayer()'
+			};
 
-								if ( options.type == 'earth' ) {
-									map.setMapTypeId( GoogleEarth.MAP_TYPE_ID );
-									setTilt();
-								}
-								else {
-									google.maps.event.addListenerOnce( map, 'maptypeid_changed', function() { setTilt(); } );
-								}
-							}
+			for (i = options.layers.length - 1; i >= 0; i--) {
+				var layer = eval(layerMapping[options.layers[i]]);
+				layer.setMap(map);
+			}
+
+			var bounds;
 
-							_this.addOverlays();
-						} );
-					} } );
+			if (( options.centre === false || options.zoom === false ) && options.locations.length > 1) {
+				bounds = new google.maps.LatLngBounds();
+
+				for (var i = this.markers.length - 1; i >= 0; i--) {
+					bounds.extend(this.markers[i].getPosition());
 				}
-			);
-		}
-		else {
-			google.maps.event.addListenerOnce( map, 'tilesloaded', function() { _this.addOverlays(); } );
-		}
+			}
 
-		if ( options.autoinfowindows ) {
-			for ( var i = this.markers.length - 1; i >= 0; i-- ) {
-				google.maps.event.trigger( this.markers[i], 'click' );
+			if (options.zoom === false) {
+				map.fitBounds(bounds);
+			}
+			else {
+				map.setZoom(options.zoom);
 			}
-		}
 
-		if ( options.resizable ) {
-			mw.loader.using( 'ext.maps.resizable', function() {
-				_this.resizable();
-			} );
-		}
+			var centre;
 
-		/**
-		 * used in display_line functionality
-		 * draws paths between markers
-		 */
-		if(options.lines){
-			for ( var i = 0; i < options.lines.length; i++ ) {
-				this.addLine(options.lines[i]);
+			if (options.centre === false) {
+				if (options.locations.length > 1) {
+					centre = bounds.getCenter();
+				}
+				else if (options.locations.length == 1) {
+					centre = new google.maps.LatLng(options.locations[0].lat, options.locations[0].lon);
+				}
+				else {
+					centre = new google.maps.LatLng(0, 0);
+				}
 			}
-		}
-
-		/**
-		 * used in display_line to draw polygons
-		 */
-		if(options.polygons){
-			for ( var i = 0; i < options.polygons.length; i++ ) {
-				this.addPolygon(options.polygons[i]);
+			else {
+				centre = new google.maps.LatLng(options.centre.lat, options.centre.lon);
 			}
-		}
 
-		/**
-		 * used in display_line to draw circles
-		 */
-		if(options.circles){
-			for ( var i = 0; i < options.circles.length; i++ ) {
-				this.addCircle(options.circles[i]);
+			map.setCenter(centre);
+
+			if (showEarth) {
+				$.getScript(
+					'https://www.google.com/jsapi?key=' + mw.config.get('egGoogleJsApiKey'),
+					function (data, textStatus) {
+						google.load('earth', '1', { callback:function () {
+							mw.loader.using('ext.maps.gm3.earth', function () {
+								if (google.earth.isSupported()) {
+									var ge = new GoogleEarth(map);
+									var setTilt = function () {
+
+										if (ge.getInstance() !== undefined) {
+
+											var center = map.getCenter();
+											var lookAt = ge.instance_.createLookAt('');
+											var range = Math.pow(2, GoogleEarth.MAX_EARTH_ZOOM_ - map.getZoom());
+											lookAt.setRange(range);
+											lookAt.setLatitude(center.lat());
+											lookAt.setLongitude(center.lng());
+											lookAt.setHeading(0);
+											lookAt.setAltitude(0);
+
+											// Teleport to the pre-tilt view immediately.
+											ge.instance_.getOptions().setFlyToSpeed(5);
+											ge.instance_.getView().setAbstractView(lookAt);
+											lookAt.setTilt(options.tilt);
+											// Fly to the tilt at regular speed in 200ms
+											ge.instance_.getOptions().setFlyToSpeed(0.75);
+											window.setTimeout(function () {
+												ge.instance_.getView().setAbstractView(lookAt);
+											}, 200);
+											// Set the flyto speed back to default after the animation starts.
+											window.setTimeout(function () {
+												ge.instance_.getOptions().setFlyToSpeed(1);
+											}, 250);
+
+										}
+										else {
+											setTimeout(function () {
+												setTilt();
+											}, 100);
+										}
+									};
+
+									if (options.type == 'earth') {
+										map.setMapTypeId(GoogleEarth.MAP_TYPE_ID);
+										setTilt();
+									}
+									else {
+										google.maps.event.addListenerOnce(map, 'maptypeid_changed', function () {
+											setTilt();
+										});
+									}
+								}
+
+								_this.addOverlays();
+							});
+						} });
+					}
+				);
+			}
+			else {
+				google.maps.event.addListenerOnce(map, 'tilesloaded', function () {
+					_this.addOverlays();
+				});
 			}
-		}
 
-		/**
-		 * used in display_line to draw rectangles
-		 */
-		if(options.rectangles){
-			for ( var i = 0; i < options.rectangles.length; i++ ) {
-				this.addRectangle(options.rectangles[i]);
+			if (options.autoinfowindows) {
+				for (var i = this.markers.length - 1; i >= 0; i--) {
+					google.maps.event.trigger(this.markers[i], 'click');
+				}
 			}
-		}
 
-		/**
-		 * used in display_line functionality
-		 * allows the copy to clipboard of coordinates
-		 */
-		if(options.copycoords){
-			function addRightClickListener(object){
-				google.maps.event.addListener( object, 'rightclick', function(event) {
-					prompt(mediaWiki.msg( 'maps-copycoords-prompt' ),event.latLng.lat()+','+event.latLng.lng());
+			if (options.resizable) {
+				mw.loader.using('ext.maps.resizable', function () {
+					_this.resizable();
 				});
 			}
 
-			for(var x = 0; x < this.markers.length; x++){
-				addRightClickListener(this.markers[x]);
+			/**
+			 * used in display_line functionality
+			 * draws paths between markers
+			 */
+			if (options.lines) {
+				for (var i = 0; i < options.lines.length; i++) {
+					this.addLine(options.lines[i]);
+				}
 			}
 
-			for(var x = 0; x < this.lines.length; x++){
-				addRightClickListener(this.lines[x]);
+			/**
+			 * used in display_line to draw polygons
+			 */
+			if (options.polygons) {
+				for (var i = 0; i < options.polygons.length; i++) {
+					this.addPolygon(options.polygons[i]);
+				}
 			}
 
-			addRightClickListener(this.map);
-		}
+			/**
+			 * used in display_line to draw circles
+			 */
+			if (options.circles) {
+				for (var i = 0; i < options.circles.length; i++) {
+					this.addCircle(options.circles[i]);
+				}
+			}
 
-		/**
-		 * used in display_line functionality
-		 * allows grouping of markers
-		 */
-		if(options.markercluster){
-			this.markercluster = new MarkerClusterer(this.map,this.markers);
-		}
+			/**
+			 * used in display_line to draw rectangles
+			 */
+			if (options.rectangles) {
+				for (var i = 0; i < options.rectangles.length; i++) {
+					this.addRectangle(options.rectangles[i]);
+				}
+			}
 
-		if(options.searchmarkers){
-			var searchBox = $('<div style="text-align: right;">'+mediaWiki.msg( 'maps-searchmarkers-text' )+': <input type="text" /></div>');
-			$(this.map.getDiv()).before(searchBox);
-
-			searchBox.find('input').keyup(function(e){
-				for(var i = 0; i < _this.markers.length; i++){
-					var haystack = '';
-					var marker = _this.markers[i];
-					if(options.searchmarkers == 'title'){
-						haystack = marker.title;
-					}else if(options.searchmarkers == 'all'){
-						haystack = marker.title+marker.text;
-					}
+			/**
+			 * used in display_line functionality
+			 * allows the copy to clipboard of coordinates
+			 */
+			if (options.copycoords) {
+				function addRightClickListener(object) {
+					google.maps.event.addListener(object, 'rightclick', function (event) {
+						prompt(mediaWiki.msg('maps-copycoords-prompt'), event.latLng.lat() + ',' + event.latLng.lng());
+					});
+				}
 
-					marker.setVisible(haystack.toLowerCase().indexOf(e.target.value.toLowerCase()) != -1);
+				for (var x = 0; x < this.markers.length; x++) {
+					addRightClickListener(this.markers[x]);
 				}
-			});
-		}
 
-	};
+				for (var x = 0; x < this.lines.length; x++) {
+					addRightClickListener(this.lines[x]);
+				}
 
-	function openBubbleOrLink(properties, event, obj) {
-		if (properties.link) {
-			window.location.href = properties.link;
-		} else if(properties.text !== '') {
-			openBubble.call(this, properties, event, obj);
+				addRightClickListener(this.map);
+			}
+
+			/**
+			 * used in display_line functionality
+			 * allows grouping of markers
+			 */
+			if (options.markercluster) {
+				this.markercluster = new MarkerClusterer(this.map, this.markers);
+			}
+
+			if (options.searchmarkers) {
+				var searchBox = $('<div style="text-align: right;">' + mediaWiki.msg('maps-searchmarkers-text') + ': <input type="text" /></div>');
+				$(this.map.getDiv()).before(searchBox);
+
+				searchBox.find('input').keyup(function (e) {
+					for (var i = 0; i < _this.markers.length; i++) {
+						var haystack = '';
+						var marker = _this.markers[i];
+						if (options.searchmarkers == 'title') {
+							haystack = marker.title;
+						} else if (options.searchmarkers == 'all') {
+							haystack = marker.title + marker.text;
+						}
+
+						marker.setVisible(haystack.toLowerCase().indexOf(e.target.value.toLowerCase()) != -1);
+					}
+				});
+			}
+
+		};
+
+		function openBubbleOrLink(properties, event, obj) {
+			if (properties.link) {
+				window.location.href = properties.link;
+			} else if (properties.text !== '') {
+				openBubble.call(this, properties, event, obj);
+			}
 		}
-	}
 
-	function openBubble(properties, event, obj) {
-		if (this.openWindow != undefined) {
-			this.openWindow.close();
+		function openBubble(properties, event, obj) {
+			if (this.openWindow != undefined) {
+				this.openWindow.close();
+			}
+			this.openWindow = new google.maps.InfoWindow();
+			this.openWindow.content = properties.text;
+			this.openWindow.position = event.latLng;
+			this.openWindow.closeclick = function () {
+				obj.openWindow = undefined;
+			};
+			this.openWindow.open(this.map);
 		}
-		this.openWindow = new google.maps.InfoWindow();
-		this.openWindow.content = properties.text;
-		this.openWindow.position = event.latLng;
-		this.openWindow.closeclick = function () {
-			obj.openWindow = undefined;
-		};
-		this.openWindow.open(this.map);
-	}
 
-	this.setup();
+		this.setup();
 
-	return this;
+		return this;
 
-}; })( jQuery, window.mediaWiki );
\ No newline at end of file
+	};
+})(jQuery, window.mediaWiki);
\ No newline at end of file
diff --git a/includes/services/OpenLayers/jquery.openlayers.js b/includes/services/OpenLayers/jquery.openlayers.js
index 1825879..46e9e8e 100644
--- a/includes/services/OpenLayers/jquery.openlayers.js
+++ b/includes/services/OpenLayers/jquery.openlayers.js
@@ -6,534 +6,540 @@
  * @author Daniel Werner
  */
 
-(function( $ ){ $.fn.openlayers = function( mapElementId, options ) {
+(function ($) {
+	$.fn.openlayers = function (mapElementId, options) {
 
-	this.getOLMarker = function( markerLayer, markerData ) {
-		var marker;
+		this.getOLMarker = function (markerLayer, markerData) {
+			var marker;
 
-		if ( markerData.icon != "" ) {
-			marker = new OpenLayers.Marker( markerData.lonlat, new OpenLayers.Icon( markerData.icon ) );
-		} else {
-			marker = new OpenLayers.Marker( markerData.lonlat, new OpenLayers.Icon( markerLayer.defaultIcon ) );
-		}
-
-		// This is the handler for the mousedown event on the marker, and displays the popup.
-		marker.events.register('mousedown', marker,
-			function( evt ) {
-				if (markerData.link) {
-					window.location.href = markerData.link;
-				} else if(markerData.text !== '') {
-					var popup = new OpenLayers.Feature( markerLayer, markerData.lonlat ).createPopup( true );
-					popup.setContentHTML( markerData.text );
-					markerLayer.map.addPopup( popup );
-					OpenLayers.Event.stop( evt ); // Stop the event.
-				}
+			if (markerData.icon != "") {
+				marker = new OpenLayers.Marker(markerData.lonlat, new OpenLayers.Icon(markerData.icon));
+			} else {
+				marker = new OpenLayers.Marker(markerData.lonlat, new OpenLayers.Icon(markerLayer.defaultIcon));
 			}
-		);
 
-		return marker;
-	}
+			// This is the handler for the mousedown event on the marker, and displays the popup.
+			marker.events.register('mousedown', marker,
+				function (evt) {
+					if (markerData.link) {
+						window.location.href = markerData.link;
+					} else if (markerData.text !== '') {
+						var popup = new OpenLayers.Feature(markerLayer, markerData.lonlat).createPopup(true);
+						popup.setContentHTML(markerData.text);
+						markerLayer.map.addPopup(popup);
+						OpenLayers.Event.stop(evt); // Stop the event.
+					}
+				}
+			);
 
-	this.addMarkers = function( map, options ) {
-		if ( !options.locations ) {
-			options.locations = [];
+			return marker;
 		}
 
-		var locations = options.locations;
-		var bounds = null;
+		this.addMarkers = function (map, options) {
+			if (!options.locations) {
+				options.locations = [];
+			}
 
-		if ( locations.length > 1 && ( options.centre === false || options.zoom === false ) ) {
-			bounds = new OpenLayers.Bounds();
-		}
+			var locations = options.locations;
+			var bounds = null;
 
-		var groupLayers = new Object();
-		var groups = 0;
+			if (locations.length > 1 && ( options.centre === false || options.zoom === false )) {
+				bounds = new OpenLayers.Bounds();
+			}
 
-		for ( i = locations.length - 1; i >= 0; i-- ) {
+			var groupLayers = new Object();
+			var groups = 0;
+
+			for (i = locations.length - 1; i >= 0; i--) {
+
+				var location = locations[i];
+
+				// Create a own marker-layer for the marker group:
+				if (!groupLayers[ location.group ]) {
+					// in case no group is specified, use default marker layer:
+					var layerName = location.group != '' ? location.group : mediaWiki.msg('maps-markers');
+					var curLayer = new OpenLayers.Layer.Markers(layerName);
+					groups++;
+					curLayer.id = 'markerLayer' + groups;
+					// define default icon, one of ten in different colors, if more than ten layers, colors will repeat:
+					curLayer.defaultIcon = egMapsScriptPath + '/includes/services/OpenLayers/OpenLayers/img/marker' + ( ( groups + 10 ) % 10 ) + '.png';
+					map.addLayer(curLayer);
+					groupLayers[ location.group ] = curLayer;
+				} else {
+					// if markers of this group exist already, they have an own layer already
+					var curLayer = groupLayers[ location.group ];
+				}
 
-			var location = locations[i];
+				location.lonlat = new OpenLayers.LonLat(location.lon, location.lat);
 
-			// Create a own marker-layer for the marker group:
-			if( ! groupLayers[ location.group ] ) {
-				// in case no group is specified, use default marker layer:				
-				var layerName = location.group != '' ? location.group : mediaWiki.msg( 'maps-markers' );
-				var curLayer = new OpenLayers.Layer.Markers( layerName );
-				groups++;
-				curLayer.id = 'markerLayer' + groups;
-				// define default icon, one of ten in different colors, if more than ten layers, colors will repeat:
-				curLayer.defaultIcon = egMapsScriptPath + '/includes/services/OpenLayers/OpenLayers/img/marker' + ( ( groups + 10 ) % 10 ) + '.png';
-				map.addLayer( curLayer );
-				groupLayers[ location.group ] = curLayer;
-			} else {
-				// if markers of this group exist already, they have an own layer already
-				var curLayer = groupLayers[ location.group ];
+				if (!hasImageLayer) {
+					location.lonlat.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));
+				}
+
+				if (bounds != null) bounds.extend(location.lonlat); // Extend the bounds when no center is set.
+				var marker = this.getOLMarker(curLayer, location);
+				this.markers.push({
+					target:marker,
+					data:location
+				});
+				curLayer.addMarker(marker); // Create and add the marker.
 			}
 
-			location.lonlat = new OpenLayers.LonLat( location.lon, location.lat );
+			if (bounds != null) map.zoomToExtent(bounds); // If a bounds object has been created, use it to set the zoom and center.
+		}
 
-			if ( !hasImageLayer ) {
-				location.lonlat.transform( new OpenLayers.Projection( "EPSG:4326" ), new OpenLayers.Projection( "EPSG:900913" ) );
+		this.addControls = function (map, controls, mapElement) {
+			// Add the controls.
+			for (var i = controls.length - 1; i >= 0; i--) {
+				// If a string is provided, find the correct name for the control, and use eval to create the object itself.
+				if (typeof controls[i] == 'string') {
+					if (controls[i].toLowerCase() == 'autopanzoom') {
+						if (mapElement.offsetHeight > 140) controls[i] = mapElement.offsetHeight > 320 ? 'panzoombar' : 'panzoom';
+					}
+
+					control = getValidControlName(controls[i]);
+
+					if (control) {
+						map.addControl(eval('new OpenLayers.Control.' + control + '() '));
+					}
+				}
+				else {
+					map.addControl(controls[i]); // If a control is provided, instead a string, just add it.
+					controls[i].activate(); // And activate it.
+				}
 			}
 
-			if ( bounds != null ) bounds.extend( location.lonlat ); // Extend the bounds when no center is set.
-			var marker = this.getOLMarker( curLayer, location );
-			this.markers.push({
-				target: marker,
-				data:location
-			});
-			curLayer.addMarker( marker ); // Create and add the marker.
+			map.addControl(new OpenLayers.Control.Attribution());
 		}
 
-		if ( bounds != null ) map.zoomToExtent( bounds ); // If a bounds object has been created, use it to set the zoom and center.
-	}
+		this.addLine = function (properties) {
+			var pos = new Array();
+			for (var x = 0; x < properties.pos.length; x++) {
+				var point = new OpenLayers.Geometry.Point(properties.pos[x].lon, properties.pos[x].lat);
+				point.transform(
+					new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
+					map.getProjectionObject() // to Spherical Mercator Projection
+				);
+				pos.push(point);
+			}
 
-	this.addControls = function( map, controls, mapElement ) {
-		// Add the controls.
-		for ( var i = controls.length - 1; i >= 0; i-- ) {
-			// If a string is provided, find the correct name for the control, and use eval to create the object itself.
-			if ( typeof controls[i] == 'string' ) {
-				if ( controls[i].toLowerCase() == 'autopanzoom' ) {
-					if ( mapElement.offsetHeight > 140 ) controls[i] = mapElement.offsetHeight > 320 ? 'panzoombar' : 'panzoom';
-				}
+			var style = {
+				'strokeColor':properties.strokeColor,
+				'strokeWidth':properties.strokeWeight,
+				'strokeOpacity':properties.strokeOpacity
+			}
 
-				control = getValidControlName( controls[i] );
+			var line = new OpenLayers.Geometry.LineString(pos);
+			var lineFeature = new OpenLayers.Feature.Vector(line, properties, style);
+			this.lineLayer.addFeatures([lineFeature]);
+		}
 
-				if ( control ) {
-					map.addControl(eval('new OpenLayers.Control.' + control + '() '));
-				}
+		this.addPolygon = function (properties) {
+			var pos = new Array();
+			for (var x = 0; x < properties.pos.length; x++) {
+				var point = new OpenLayers.Geometry.Point(properties.pos[x].lon, properties.pos[x].lat);
+				point.transform(
+					new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
+					map.getProjectionObject() // to Spherical Mercator Projection
+				);
+				pos.push(point);
 			}
-			else {
-				map.addControl(controls[i]); // If a control is provided, instead a string, just add it.
-				controls[i].activate(); // And activate it.
+
+			var style = {
+				'strokeColor':properties.strokeColor,
+				'strokeWidth':properties.strokeWeight,
+				'strokeOpacity':properties.onlyVisibleOnHover === true ? 0 : properties.strokeOpacity,
+				'fillColor':properties.fillColor,
+				'fillOpacity':properties.onlyVisibleOnHover === true ? 0 : properties.fillOpacity
 			}
+
+			var polygon = new OpenLayers.Geometry.LinearRing(pos);
+			var polygonFeature = new OpenLayers.Feature.Vector(polygon, properties, style);
+			this.polygonLayer.addFeatures([polygonFeature]);
 		}
 
-		map.addControl( new OpenLayers.Control.Attribution() );
-	}
+		this.addCircle = function (properties) {
+			var style = {
+				'strokeColor':properties.strokeColor,
+				'strokeWidth':properties.strokeWeight,
+				'strokeOpacity':properties.onlyVisibleOnHover === true ? 0 : properties.strokeOpacity,
+				'fillColor':properties.fillColor,
+				'fillOpacity':properties.onlyVisibleOnHover === true ? 0 : properties.fillOpacity
+			}
 
-	this.addLine = function(properties){
-		var pos = new Array();
-		for(var x = 0; x < properties.pos.length; x++){
-			var point = new OpenLayers.Geometry.Point(properties.pos[x].lon,properties.pos[x].lat);
+			var point = new OpenLayers.Geometry.Point(properties.centre.lon, properties.centre.lat);
 			point.transform(
 				new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
 				map.getProjectionObject() // to Spherical Mercator Projection
 			);
-			pos.push(point);
-		}
-
-		var style = {
-			'strokeColor':properties.strokeColor,
-			'strokeWidth': properties.strokeWeight,
-			'strokeOpacity': properties.strokeOpacity
+			var circle = OpenLayers.Geometry.Polygon.createRegularPolygon(
+				point,
+				properties.radius,
+				30
+			);
+			var circleFeature = new OpenLayers.Feature.Vector(circle, properties, style);
+			this.circleLayer.addFeatures([circleFeature])
 		}
 
-		var line = new OpenLayers.Geometry.LineString(pos);
-		var lineFeature = new OpenLayers.Feature.Vector(line, properties, style);
-		this.lineLayer.addFeatures([lineFeature]);
-	}
+		this.addRectangle = function (properties) {
+			var style = {
+				'strokeColor':properties.strokeColor,
+				'strokeWidth':properties.strokeWeight,
+				'strokeOpacity':properties.onlyVisibleOnHover === true ? 0 : properties.strokeOpacity,
+				'fillColor':properties.fillColor,
+				'fillOpacity':properties.onlyVisibleOnHover === true ? 0 : properties.fillOpacity
+			}
 
-	this.addPolygon = function(properties){
-		var pos = new Array();
-		for(var x = 0; x < properties.pos.length; x++){
-			var point = new OpenLayers.Geometry.Point(properties.pos[x].lon,properties.pos[x].lat);
-			point.transform(
+			var point1 = new OpenLayers.Geometry.Point(properties.ne.lon, properties.ne.lat);
+			var point2 = new OpenLayers.Geometry.Point(properties.sw.lon, properties.sw.lat);
+			point1.transform(
+				new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
+				map.getProjectionObject() // to Spherical Mercator Projection
+			);
+			point2.transform(
 				new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
 				map.getProjectionObject() // to Spherical Mercator Projection
 			);
-			pos.push(point);
-		}
 
-		var style = {
-			'strokeColor':properties.strokeColor,
-			'strokeWidth': properties.strokeWeight,
-			'strokeOpacity': properties.onlyVisibleOnHover === true ? 0 : properties.strokeOpacity,
-			'fillColor': properties.fillColor,
-			'fillOpacity': properties.onlyVisibleOnHover === true ? 0 : properties.fillOpacity
-		}
+			var bounds = new OpenLayers.Bounds();
+			bounds.extend(point1);
+			bounds.extend(point2);
 
-		var polygon = new OpenLayers.Geometry.LinearRing(pos);
-		var polygonFeature = new OpenLayers.Feature.Vector(polygon, properties, style);
-		this.polygonLayer.addFeatures([polygonFeature]);
-	}
-
-	this.addCircle = function(properties){
-		var style = {
-			'strokeColor':properties.strokeColor,
-			'strokeWidth': properties.strokeWeight,
-			'strokeOpacity': properties.onlyVisibleOnHover === true ? 0 : properties.strokeOpacity,
-			'fillColor': properties.fillColor,
-			'fillOpacity': properties.onlyVisibleOnHover === true ? 0 : properties.fillOpacity
+			var rectangle = bounds.toGeometry();
+			var rectangleFeature = new OpenLayers.Feature.Vector(rectangle, properties, style);
+			this.rectangleLayer.addFeatures([rectangleFeature])
 		}
 
-		var point = new OpenLayers.Geometry.Point(properties.centre.lon,properties.centre.lat);
-		point.transform(
-			new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
-			map.getProjectionObject() // to Spherical Mercator Projection
-		);
-		var circle = OpenLayers.Geometry.Polygon.createRegularPolygon(
-			point,
-			properties.radius,
-			30
-		);
-		var circleFeature = new OpenLayers.Feature.Vector(circle,properties,style);
-		this.circleLayer.addFeatures([circleFeature])
-	}
-
-	this.addRectangle = function(properties){
-		var style = {
-			'strokeColor':properties.strokeColor,
-			'strokeWidth': properties.strokeWeight,
-			'strokeOpacity': properties.onlyVisibleOnHover === true ? 0 : properties.strokeOpacity,
-			'fillColor': properties.fillColor,
-			'fillOpacity': properties.onlyVisibleOnHover === true ? 0 : properties.fillOpacity
+		/**
+		 * Gets a valid control name (with excat lower and upper case letters),
+		 * or returns false when the control is not allowed.
+		 */
+		function getValidControlName(control) {
+			var OLControls = [
+				'ArgParser', 'Attribution', 'Button', 'DragFeature', 'DragPan',
+				'DrawFeature', 'EditingToolbar', 'GetFeature', 'KeyboardDefaults', 'LayerSwitcher',
+				'Measure', 'ModifyFeature', 'MouseDefaults', 'MousePosition', 'MouseToolbar',
+				'Navigation', 'NavigationHistory', 'NavToolbar', 'OverviewMap', 'Pan',
+				'Panel', 'PanPanel', 'PanZoom', 'PanZoomBar', 'Permalink',
+				'Scale', 'ScaleLine', 'SelectFeature', 'Snapping', 'Split',
+				'WMSGetFeatureInfo', 'ZoomBox', 'ZoomIn', 'ZoomOut', 'ZoomPanel',
+				'ZoomToMaxExtent'
+			];
+
+			for (var i = OLControls.length - 1; i >= 0; i--) {
+				if (control == OLControls[i].toLowerCase()) {
+					return OLControls[i];
+				}
+			}
+
+			return false;
 		}
 
-		var point1 = new OpenLayers.Geometry.Point(properties.ne.lon,properties.ne.lat);
-		var point2 = new OpenLayers.Geometry.Point(properties.sw.lon,properties.sw.lat);
-		point1.transform(
-			new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
-			map.getProjectionObject() // to Spherical Mercator Projection
-		);
-		point2.transform(
-			new OpenLayers.Projection("EPSG:4326"), // transform from WGS 1984
-			map.getProjectionObject() // to Spherical Mercator Projection
-		);
-
-		var bounds = new OpenLayers.Bounds();
-		bounds.extend(point1);
-		bounds.extend(point2);
-
-		var rectangle = bounds.toGeometry();
-		var rectangleFeature = new OpenLayers.Feature.Vector(rectangle,properties,style);
-		this.rectangleLayer.addFeatures([rectangleFeature])
-	}
-
-	/**
-	 * Gets a valid control name (with excat lower and upper case letters),
-	 * or returns false when the control is not allowed.
-	 */
-	function getValidControlName( control ) {
-		var OLControls = [
-			'ArgParser', 'Attribution', 'Button', 'DragFeature', 'DragPan',
-			'DrawFeature', 'EditingToolbar', 'GetFeature', 'KeyboardDefaults', 'LayerSwitcher',
-			'Measure', 'ModifyFeature', 'MouseDefaults', 'MousePosition', 'MouseToolbar',
-			'Navigation', 'NavigationHistory', 'NavToolbar', 'OverviewMap', 'Pan',
-			'Panel', 'PanPanel', 'PanZoom', 'PanZoomBar', 'Permalink',
-			'Scale', 'ScaleLine', 'SelectFeature', 'Snapping', 'Split',
-			'WMSGetFeatureInfo', 'ZoomBox', 'ZoomIn', 'ZoomOut', 'ZoomPanel',
-			'ZoomToMaxExtent'
-		];
-
-		for ( var i = OLControls.length - 1; i >= 0; i-- ) {
-			if ( control == OLControls[i].toLowerCase() ) {
-				return OLControls[i];
+		var _this = this;
+		this.markers = [];
+
+		// Remove the loading map message.
+		this.text('');
+
+		// Create a new OpenLayers map with without any controls on it.
+		var mapOptions = {
+			controls:[]
+		};
+
+		var hasImageLayer = false;
+		for (i = 0, n = options.layers.length; i < n; i++) {
+			// Idieally this would check if the objecct is of type OpenLayers.layer.image
+			options.layers[i] = eval(options.layers[i])
+			if (options.layers[i].options && options.layers[i].options.isImage === true) {
+				hasImageLayer = true;
+				break;
 			}
 		}
 
-		return false;
-	}
-
-	var _this = this;
-	this.markers = [];
+		if (!hasImageLayer) {
+			mapOptions.projection = new OpenLayers.Projection("EPSG:900913");
+			mapOptions.displayProjection = new OpenLayers.Projection("EPSG:4326");
+			mapOptions.units = "m";
+			mapOptions.numZoomLevels = 18;
+			mapOptions.maxResolution = 156543.0339;
+			mapOptions.maxExtent = new OpenLayers.Bounds(-20037508, -20037508, 20037508, 20037508.34);
+		}
 
-	// Remove the loading map message.
-	this.text( '' );
+		this.map = new OpenLayers.Map(mapElementId, mapOptions);
+		var map = this.map;
 
-	// Create a new OpenLayers map with without any controls on it.
-	var mapOptions = {
-		controls: []
-	};
+		if (!options['static']) {
+			this.addControls(map, options.controls, this.get(0));
+		}
 
-	var hasImageLayer = false;
-	for ( i = 0, n = options.layers.length; i < n; i++ ) {
-		// Idieally this would check if the objecct is of type OpenLayers.layer.image
-		options.layers[i] = eval(options.layers[i])
-		if ( options.layers[i].options && options.layers[i].options.isImage === true ) {
-			hasImageLayer = true;
-			break;
+		// Add the base layers.
+		for (i = 0, n = options.layers.length; i < n; i++) {
+			map.addLayer(options.layers[i]);
 		}
-	}
-
-	if ( !hasImageLayer ) {
-		mapOptions.projection = new OpenLayers.Projection("EPSG:900913");
-		mapOptions.displayProjection = new OpenLayers.Projection("EPSG:4326");
-		mapOptions.units = "m";
-		mapOptions.numZoomLevels = 18;
-		mapOptions.maxResolution = 156543.0339;
-		mapOptions.maxExtent = new OpenLayers.Bounds(-20037508, -20037508, 20037508, 20037508.34);
-	}
-
-
-	this.map = new OpenLayers.Map( mapElementId, mapOptions );
-	var map = this.map;
-	this.addControls( map, options.controls, this.get( 0 ) );
-
-	// Add the base layers.
-	for ( i = 0, n = options.layers.length; i < n; i++ ) {
-		map.addLayer(options.layers[i] );
-	}
-
-	//Add markers
-	this.addMarkers( map, options );
-	var centre = false;
-
-	//Add line layer if applicable
-	if(options.lines && options.lines.length > 0){
-		this.lineLayer = new OpenLayers.Layer.Vector("Line Layer");
-
-		var controls = {
-			select: new OpenLayers.Control.SelectFeature(this.lineLayer,{
-				clickout: true, toggle: false,
-				multiple: true, hover: true,
-				callbacks: {
-					'click':function(feature){
-						openBubbleOrLink(feature.attributes);
+
+		//Add markers
+		this.addMarkers(map, options);
+		var centre = false;
+
+		//Add line layer if applicable
+		if (options.lines && options.lines.length > 0) {
+			this.lineLayer = new OpenLayers.Layer.Vector("Line Layer");
+
+			var controls = {
+				select:new OpenLayers.Control.SelectFeature(this.lineLayer, {
+					clickout:true, toggle:false,
+					multiple:true, hover:true,
+					callbacks:{
+						'click':function (feature) {
+							openBubbleOrLink(feature.attributes);
+						}
 					}
-				}
-			})
-		};
+				})
+			};
 
-		for(key in controls){
-			var control = controls[key];
-			map.addControl(control);
-			control.activate();
-		}
+			for (key in controls) {
+				var control = controls[key];
+				map.addControl(control);
+				control.activate();
+			}
 
-		map.addLayer(this.lineLayer);
-		map.raiseLayer(this.lineLayer,-1);
-		map.resetLayersZIndex();
+			map.addLayer(this.lineLayer);
+			map.raiseLayer(this.lineLayer, -1);
+			map.resetLayersZIndex();
 
-		for ( var i = 0; i < options.lines.length; i++ ) {
-			this.addLine(options.lines[i]);
+			for (var i = 0; i < options.lines.length; i++) {
+				this.addLine(options.lines[i]);
+			}
 		}
-	}
-
-	if(options.polygons && options.polygons.length > 0){
-		this.polygonLayer = new OpenLayers.Layer.Vector("Polygon Layer");
-
-		var controls = {
-			select: new OpenLayers.Control.SelectFeature(this.polygonLayer,{
-				clickout: true, toggle: false,
-				multiple: true, hover: true,
-				callbacks: {
-					'over':function(feature){
-						if(feature.attributes.onlyVisibleOnHover === true){
-							var style = {
-								'strokeColor':feature.attributes.strokeColor,
-								'strokeWidth': feature.attributes.strokeWeight,
-								'strokeOpacity': feature.attributes.strokeOpacity,
-								'fillColor': feature.attributes.fillColor,
-								'fillOpacity': feature.attributes.fillOpacity
+
+		if (options.polygons && options.polygons.length > 0) {
+			this.polygonLayer = new OpenLayers.Layer.Vector("Polygon Layer");
+
+			var controls = {
+				select:new OpenLayers.Control.SelectFeature(this.polygonLayer, {
+					clickout:true, toggle:false,
+					multiple:true, hover:true,
+					callbacks:{
+						'over':function (feature) {
+							if (feature.attributes.onlyVisibleOnHover === true) {
+								var style = {
+									'strokeColor':feature.attributes.strokeColor,
+									'strokeWidth':feature.attributes.strokeWeight,
+									'strokeOpacity':feature.attributes.strokeOpacity,
+									'fillColor':feature.attributes.fillColor,
+									'fillOpacity':feature.attributes.fillOpacity
+								}
+								_this.polygonLayer.drawFeature(feature, style);
 							}
-							_this.polygonLayer.drawFeature(feature,style);
-						}
-					},
-					'out':function(feature){
-						if(feature.attributes.onlyVisibleOnHover === true && _this.map.popups.length === 0){
-							var style = {
-								'strokeColor':feature.attributes.strokeColor,
-								'strokeWidth': feature.attributes.strokeWeight,
-								'strokeOpacity': 0,
-								'fillColor': feature.attributes.fillColor,
-								'fillOpacity': 0
+						},
+						'out':function (feature) {
+							if (feature.attributes.onlyVisibleOnHover === true && _this.map.popups.length === 0) {
+								var style = {
+									'strokeColor':feature.attributes.strokeColor,
+									'strokeWidth':feature.attributes.strokeWeight,
+									'strokeOpacity':0,
+									'fillColor':feature.attributes.fillColor,
+									'fillOpacity':0
+								}
+								_this.polygonLayer.drawFeature(feature, style);
 							}
-							_this.polygonLayer.drawFeature(feature,style);
+						},
+						'click':function (feature) {
+							openBubbleOrLink(feature.attributes);
 						}
-					},
-					'click':function(feature){
-						openBubbleOrLink(feature.attributes);
 					}
-				}
-			})
-		};
+				})
+			};
 
-		for(key in controls){
-			var control = controls[key];
-			map.addControl(control);
-			control.activate();
-		}
+			for (key in controls) {
+				var control = controls[key];
+				map.addControl(control);
+				control.activate();
+			}
 
-		map.addLayer(this.polygonLayer);
-		map.raiseLayer(this.polygonLayer,-1);
-		map.resetLayersZIndex();
+			map.addLayer(this.polygonLayer);
+			map.raiseLayer(this.polygonLayer, -1);
+			map.resetLayersZIndex();
 
-		for ( var i = 0; i < options.polygons.length; i++ ) {
-			this.addPolygon(options.polygons[i]);
+			for (var i = 0; i < options.polygons.length; i++) {
+				this.addPolygon(options.polygons[i]);
+			}
 		}
-	}
-
-	if(options.circles && options.circles.length > 0){
-		this.circleLayer = new OpenLayers.Layer.Vector("Circle Layer");
-
-		var controls = {
-			select: new OpenLayers.Control.SelectFeature(this.circleLayer,{
-				clickout: true, toggle: false,
-				multiple: true, hover: true,
-				callbacks: {
-					'click':function(feature){
-						openBubbleOrLink(feature.attributes);
+
+		if (options.circles && options.circles.length > 0) {
+			this.circleLayer = new OpenLayers.Layer.Vector("Circle Layer");
+
+			var controls = {
+				select:new OpenLayers.Control.SelectFeature(this.circleLayer, {
+					clickout:true, toggle:false,
+					multiple:true, hover:true,
+					callbacks:{
+						'click':function (feature) {
+							openBubbleOrLink(feature.attributes);
+						}
 					}
-				}
-			})
-		};
+				})
+			};
 
-		for(key in controls){
-			var control = controls[key];
-			map.addControl(control);
-			control.activate();
-		}
+			for (key in controls) {
+				var control = controls[key];
+				map.addControl(control);
+				control.activate();
+			}
 
-		map.addLayer(this.circleLayer);
-		map.raiseLayer(this.circleLayer,-1);
-		map.resetLayersZIndex();
+			map.addLayer(this.circleLayer);
+			map.raiseLayer(this.circleLayer, -1);
+			map.resetLayersZIndex();
 
-		for ( var i = 0; i < options.circles.length; i++ ) {
-			this.addCircle(options.circles[i]);
+			for (var i = 0; i < options.circles.length; i++) {
+				this.addCircle(options.circles[i]);
+			}
 		}
-	}
 
 
-	if(options.rectangles && options.rectangles.length > 0){
-		this.rectangleLayer = new OpenLayers.Layer.Vector("Rectangle Layer");
+		if (options.rectangles && options.rectangles.length > 0) {
+			this.rectangleLayer = new OpenLayers.Layer.Vector("Rectangle Layer");
 
-		var controls = {
-			select: new OpenLayers.Control.SelectFeature(this.rectangleLayer,{
-				clickout: true, toggle: false,
-				multiple: true, hover: true,
-				callbacks: {
-					'click':function(feature){
-						openBubbleOrLink(feature.attributes);
+			var controls = {
+				select:new OpenLayers.Control.SelectFeature(this.rectangleLayer, {
+					clickout:true, toggle:false,
+					multiple:true, hover:true,
+					callbacks:{
+						'click':function (feature) {
+							openBubbleOrLink(feature.attributes);
+						}
 					}
-				}
-			})
-		};
+				})
+			};
 
-		for(key in controls){
-			var control = controls[key];
-			map.addControl(control);
-			control.activate();
-		}
+			for (key in controls) {
+				var control = controls[key];
+				map.addControl(control);
+				control.activate();
+			}
 
-		map.addLayer(this.rectangleLayer);
-		map.raiseLayer(this.rectangleLayer,-1);
-		map.resetLayersZIndex();
+			map.addLayer(this.rectangleLayer);
+			map.raiseLayer(this.rectangleLayer, -1);
+			map.resetLayersZIndex();
 
-		for ( var i = 0; i < options.rectangles.length; i++ ) {
-			this.addRectangle(options.rectangles[i]);
+			for (var i = 0; i < options.rectangles.length; i++) {
+				this.addRectangle(options.rectangles[i]);
+			}
 		}
-	}
-
-	if ( options.zoom !== false ) {
-		map.zoomTo( options.zoom );
-	}
 
-	if ( options.centre === false ) {
-		if ( options.locations.length == 1 ) {
-			centre = new OpenLayers.LonLat( options.locations[0].lon, options.locations[0].lat );
+		if (options.zoom !== false) {
+			map.zoomTo(options.zoom);
 		}
-		else if ( options.locations.length == 0 ) {
-			centre = new OpenLayers.LonLat( 0, 0 );
+
+		if (options.centre === false) {
+			if (options.locations.length == 1) {
+				centre = new OpenLayers.LonLat(options.locations[0].lon, options.locations[0].lat);
+			}
+			else if (options.locations.length == 0) {
+				centre = new OpenLayers.LonLat(0, 0);
+			}
 		}
-	}
-	else { // When the center is provided, set it.
-		centre = new OpenLayers.LonLat( options.centre.lon, options.centre.lat );
-	}
-
-	if ( centre !== false ) {
-		if ( !hasImageLayer ) {
-			centre.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));
-			map.setCenter( centre );
-		}else{
-			map.zoomToMaxExtent();
+		else { // When the center is provided, set it.
+			centre = new OpenLayers.LonLat(options.centre.lon, options.centre.lat);
 		}
-	}
-
-	if ( options.resizable ) {
-		mw.loader.using( 'ext.maps.resizable', function() {
-			_this.resizable();
-		} );
-	}
-
-	if(options.copycoords){
-		map.div.oncontextmenu = function(){return false;};
-		OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {
-			defaultHandlerOptions: {
-				'single': true,
-				'double': false,
-				'pixelTolerance': 0,
-				'stopSingle': false,
-				'stopDouble': false
-			},
-			handleRightClicks:true,
-
-			initialize: function(options) {
-				this.handlerOptions = OpenLayers.Util.extend(
-					{}, this.defaultHandlerOptions
-				);
-				OpenLayers.Control.prototype.initialize.apply(
-					this, arguments
-				);
-				this.handler = new OpenLayers.Handler.Click(
-					this, this.eventMethods, this.handlerOptions
-				);
+
+		if (centre !== false) {
+			if (!hasImageLayer) {
+				centre.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));
+				map.setCenter(centre);
+			} else {
+				map.zoomToMaxExtent();
 			}
+		}
+
+		if (options.resizable) {
+			mw.loader.using('ext.maps.resizable', function () {
+				_this.resizable();
+			});
+		}
 
-		})
-		var click = new OpenLayers.Control.Click({
-			eventMethods:{
-				'rightclick': function(e){
-					var lonlat = map.getLonLatFromViewPortPx(e.xy);
-					lonlat = lonlat.transform(new OpenLayers.Projection("EPSG:900913"), new OpenLayers.Projection("EPSG:4326"));
-					prompt(mediaWiki.msg( 'maps-copycoords-prompt' ),lonlat.lat+','+lonlat.lon);
+		if (options.copycoords) {
+			map.div.oncontextmenu = function () {
+				return false;
+			};
+			OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {
+				defaultHandlerOptions:{
+					'single':true,
+					'double':false,
+					'pixelTolerance':0,
+					'stopSingle':false,
+					'stopDouble':false
+				},
+				handleRightClicks:true,
+
+				initialize:function (options) {
+					this.handlerOptions = OpenLayers.Util.extend(
+						{}, this.defaultHandlerOptions
+					);
+					OpenLayers.Control.prototype.initialize.apply(
+						this, arguments
+					);
+					this.handler = new OpenLayers.Handler.Click(
+						this, this.eventMethods, this.handlerOptions
+					);
 				}
-			}
-		});
-		map.addControl(click);
-		click.activate();
-	}
-
-	if(options.markercluster){
-		alert(mediaWiki.msg('maps-clustering-unsupportedservice'));
-	}
-
-	if(options.searchmarkers){
-		var searchBox = $('<div style="text-align: right;">'+mediaWiki.msg( 'maps-searchmarkers-text' )+': <input type="text" /></div>');
-		$(this.map.div).before(searchBox);
-
-		searchBox.find('input').keyup(function(e){
-			for(var i = 0; i < _this.markers.length; i++){
-				var haystack = '';
-				var marker = _this.markers[i];
-				if(options.searchmarkers == 'title'){
-					haystack = marker.data.title;
-				}else if(options.searchmarkers == 'all'){
-					haystack = marker.data.title+marker.data.text;
+
+			})
+			var click = new OpenLayers.Control.Click({
+				eventMethods:{
+					'rightclick':function (e) {
+						var lonlat = map.getLonLatFromViewPortPx(e.xy);
+						lonlat = lonlat.transform(new OpenLayers.Projection("EPSG:900913"), new OpenLayers.Projection("EPSG:4326"));
+						prompt(mediaWiki.msg('maps-copycoords-prompt'), lonlat.lat + ',' + lonlat.lon);
+					}
+				}
+			});
+			map.addControl(click);
+			click.activate();
+		}
+
+		if (options.markercluster) {
+			alert(mediaWiki.msg('maps-clustering-unsupportedservice'));
+		}
+
+		if (options.searchmarkers) {
+			var searchBox = $('<div style="text-align: right;">' + mediaWiki.msg('maps-searchmarkers-text') + ': <input type="text" /></div>');
+			$(this.map.div).before(searchBox);
+
+			searchBox.find('input').keyup(function (e) {
+				for (var i = 0; i < _this.markers.length; i++) {
+					var haystack = '';
+					var marker = _this.markers[i];
+					if (options.searchmarkers == 'title') {
+						haystack = marker.data.title;
+					} else if (options.searchmarkers == 'all') {
+						haystack = marker.data.title + marker.data.text;
+					}
+
+					marker.target.display(haystack.toLowerCase().indexOf(e.target.value.toLowerCase()) != -1);
 				}
+			});
+		}
 
-				marker.target.display(haystack.toLowerCase().indexOf(e.target.value.toLowerCase()) != -1);
+		function openBubbleOrLink(properties) {
+			if (properties.link) {
+				window.location.href = properties.link;
+			} else if (properties.text !== '') {
+				openBubble(properties);
 			}
-		});
-	}
-
-	function openBubbleOrLink(properties) {
-		if (properties.link) {
-			window.location.href = properties.link;
-		} else if(properties.text !== '') {
-			openBubble(properties);
 		}
-	}
 
-	function openBubble(properties) {
-		var mousePos = map.getControlsByClass("OpenLayers.Control.MousePosition")[0].lastXy
-		var lonlat = map.getLonLatFromPixel(mousePos);
-		var popup = new OpenLayers.Popup(null,lonlat, null, properties.text, true,function(){
-			map.getControlsByClass('OpenLayers.Control.SelectFeature')[0].unselectAll();
-			map.removePopup(this);
-		})
-		_this.map.addPopup( popup );
-	}
+		function openBubble(properties) {
+			var mousePos = map.getControlsByClass("OpenLayers.Control.MousePosition")[0].lastXy
+			var lonlat = map.getLonLatFromPixel(mousePos);
+			var popup = new OpenLayers.Popup(null, lonlat, null, properties.text, true, function () {
+				map.getControlsByClass('OpenLayers.Control.SelectFeature')[0].unselectAll();
+				map.removePopup(this);
+			})
+			_this.map.addPopup(popup);
+		}
 
-	return this;
+		return this;
 
-}; })( jQuery );
+	};
+})(jQuery);
-- 
1.7.9.5

